// this a a code for sellers date and overview and any date range picker version 1
import { useState, useEffect } from "react";
import {
  Autocomplete,
  TextField,
  Box,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  Button,
  Divider,
} from "@mui/material";
import moment from "moment";
import { t } from "i18next";
import { defaultArchiveDate } from "statics/statics";
import { useSelector } from "react-redux";
import { Icon } from "components/icon";
import { autocompleteicon } from "assets-v1/general-Icons";
import { EnumEmployeeRole } from "statics/enums";
import StyledAutocompleteFilter from "components-v1/mui-styled-components/autocomplete/autocomplete-filter";
import { ChevronUp, ChevronDown } from "lucide-react";

const DateFilterDropdown = ({
  dates,
  setDates,
  query,
  setQuery,
  startDateQuery,
  endDateQuery,
  autocompleteLabel,
  width = 350,
}) => {
  const isArchive = useSelector((state: any) => state.employee.isArchiveData);
  const employee = useSelector((state: any) => state.employee.currentEmployee);

  const [openDateDialog, setOpenDateDialog] = useState(false);
  const [dateFilterOption, setDateFilterOption] = useState(null);
  const [tempDates, setTempDates] = useState(dates);
  const [selectedFilter, setSelectedFilter] = useState("today");
  const [leftMonth, setLeftMonth] = useState(new Date());
  const [rightMonth, setRightMonth] = useState(() => {
    const date = new Date();
    date.setMonth(date.getMonth() + 1);
    return date;
  });
  const [selectedStartDate, setSelectedStartDate] = useState(null);
  const [selectedEndDate, setSelectedEndDate] = useState(null);

  useEffect(() => {
    setTempDates(dates);
  }, [dates]);

  const dateOptions = [
    {
      label: "today",
      getDates: () => [moment(), moment().add(1, "day")],
    },
    {
      label: "last 7 days",
      getDates: () => [moment().subtract(7, "days"), moment().add(1, "day")],
    },
    {
      label: "last 30 days",
      getDates: () => [moment().subtract(30, "days"), moment().add(1, "day")],
    },
    {
      label: "last 90 days",
      getDates: () => [moment().subtract(90, "days"), moment().add(1, "day")],
    },
    {
      label: "2021",
      getDates: () => [moment("2021-01-01"), moment("2021-12-31")],
    },
    {
      label: "2020",
      getDates: () => [moment("2020-01-01"), moment("2020-12-31")],
    },
    {
      label: "2019",
      getDates: () => [moment("2019-01-01"), moment("2019-12-31")],
    },
    { label: "custom", getDates: () => null },
  ];

  useEffect(() => {
    const formattedStart = moment(tempDates[0]?.startDate).format("DD/MM/YYYY");
    const formattedEnd = moment(tempDates[0]?.endDate).format("DD/MM/YYYY");
    if (tempDates[0]?.fromFilter) {
      for (const option of dateOptions.filter(
        (option) => option.label !== "custom"
      )) {
        const [startDate, endDate] = option.getDates?.() || [];
        if (
          startDate &&
          endDate &&
          moment(tempDates[0]?.startDate).isSame(startDate, "day") &&
          moment(tempDates[0]?.endDate).isSame(endDate, "day")
        ) {
          setDateFilterOption(option);
          break;
        } else if (tempDates[0]?.startDate === undefined) {
          setDateFilterOption(option);
        } else {
          if (formattedStart === formattedEnd) {
            setDateFilterOption({
              label: `${formattedStart}`,
            });
          } else {
            setDateFilterOption({
              label: `${formattedStart} ${t("to")} ${formattedEnd}`,
            });
          }
        }
      }
    } else
      setDateFilterOption({
        label: ``,
      });
  }, [tempDates]);

  const handleDateChange = (option) => {
    setDateFilterOption(option);
    if (option.label === "custom") {
      setOpenDateDialog(true);
    } else if (option.label === t("all time")) {
      setQuery((prevQuery) => {
        const newQuery = { ...prevQuery };
        delete newQuery[startDateQuery];
        delete newQuery[endDateQuery];
        return newQuery;
      });

      setDates([
        {
          fromFilter: true,
          key: "selection",
        },
      ]);
    } else {
      const [startDate, endDate] = option.getDates();
      setQuery((prevQuery) => {
        const newQuery = {
          ...prevQuery,
          [startDateQuery]: startDate.format("YYYY-MM-DD"),
        };
        if (newQuery[endDateQuery]) delete newQuery[endDateQuery];
        return newQuery;
      });

      setDates([
        {
          startDate: startDate.toDate(),
          endDate: endDate.toDate(),
          fromFilter: true,
          key: "selection",
        },
      ]);
    }
  };

  const handleFilterSelect = (type) => {
    setSelectedFilter(type);
    const option = dateOptions.find((opt) => opt.label === type);
    if (option && option.label !== "custom") {
      const [startDate, endDate] = option.getDates();
      setSelectedStartDate(startDate.toDate());
      setSelectedEndDate(endDate.toDate());
      setTempDates([
        {
          startDate: startDate.toDate(),
          endDate: endDate.toDate(),
          fromFilter: true,
          key: "selection",
        },
      ]);
    }
  };

  const handleDateClick = (day, month, year) => {
    const clickedDate = new Date(year, month, day);
    
    if (!selectedStartDate || (selectedStartDate && selectedEndDate)) {
      // Start new selection
      setSelectedStartDate(clickedDate);
      setSelectedEndDate(null);
    } else {
      // Complete selection
      if (clickedDate >= selectedStartDate) {
        setSelectedEndDate(clickedDate);
      } else {
        setSelectedEndDate(selectedStartDate);
        setSelectedStartDate(clickedDate);
      }
    }
  };

  const applyCustomDate = () => {
    if (selectedStartDate && selectedEndDate) {
      setDates([
        {
          startDate: selectedStartDate,
          endDate: selectedEndDate,
          fromFilter: true,
          key: "selection",
        },
      ]);
      const startDate = moment(selectedStartDate).format("YYYY-MM-DD");
      const endDate = moment(selectedEndDate).format("YYYY-MM-DD");
      setQuery({
        ...query,
        [startDateQuery]: startDate,
        [endDateQuery]: endDate,
      });

      const formattedStart = moment(selectedStartDate).format("DD/MM/YYYY");
      const formattedEnd = moment(selectedEndDate).format("DD/MM/YYYY");
      if (formattedStart === formattedEnd) {
        setDateFilterOption({
          label: `${formattedStart}`,
        });
      } else {
        setDateFilterOption({
          label: `${formattedStart} ${t("to")} ${formattedEnd}`,
        });
      }
    } else if (tempDates[0]) {
      setDates([{ ...tempDates[0], fromFilter: true }]);
      const startDate = moment(tempDates[0].startDate).format("YYYY-MM-DD");
      const endDate = moment(tempDates[0].endDate).format("YYYY-MM-DD");
      setQuery({
        ...query,
        [startDateQuery]: startDate,
        [endDateQuery]: endDate,
      });

      const formattedStart = moment(tempDates[0].startDate).format("DD/MM/YYYY");
      const formattedEnd = moment(tempDates[0].endDate).format("DD/MM/YYYY");
      if (formattedStart === formattedEnd) {
        setDateFilterOption({
          label: `${formattedStart}`,
        });
      } else {
        setDateFilterOption({
          label: `${formattedStart} ${t("to")} ${formattedEnd}`,
        });
      }
    }

    setOpenDateDialog(false);
  };

  const changeLeftMonth = (increment) => {
    const newDate = new Date(leftMonth);
    newDate.setMonth(newDate.getMonth() + increment);
    setLeftMonth(newDate);
  };

  const changeRightMonth = (increment) => {
    const newDate = new Date(rightMonth);
    newDate.setMonth(newDate.getMonth() + increment);
    setRightMonth(newDate);
  };

  const getDaysInMonth = (date) => {
    const year = date.getFullYear();
    const month = date.getMonth();
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const daysInMonth = lastDay.getDate();
    const startingDayOfWeek = firstDay.getDay();

    return { daysInMonth, startingDayOfWeek, year, month };
  };

  const isDateInRange = (day, month, year) => {
    if (!selectedStartDate) return false;
    const date = new Date(year, month, day);
    if (selectedEndDate) {
      return date >= selectedStartDate && date <= selectedEndDate;
    }
    return date.getTime() === selectedStartDate.getTime();
  };

  const renderCalendar = (currentDate, onMonthChange) => {
    const { daysInMonth, startingDayOfWeek, year, month } =
      getDaysInMonth(currentDate);

    const monthNames = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ];
    const dayNames = ["Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"];

    const days = [];
    const adjustedStartDay = startingDayOfWeek === 0 ? 6 : startingDayOfWeek - 1;

    const prevMonthDays = new Date(year, month, 0).getDate();
    for (let i = adjustedStartDay - 1; i >= 0; i--) {
      days.push({ day: prevMonthDays - i, isCurrentMonth: false, month: month - 1, year });
    }

    for (let i = 1; i <= daysInMonth; i++) {
      days.push({ day: i, isCurrentMonth: true, month, year });
    }

    const remainingDays = 42 - days.length;
    for (let i = 1; i <= remainingDays; i++) {
      days.push({ day: i, isCurrentMonth: false, month: month + 1, year });
    }

    return (
      <Box sx={{ flex: 1, minWidth: "280px" }}>
        <Box
          sx={{
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            mb: 2,
          }}
        >
          <Box sx={{ fontWeight: 600, fontSize: "14px" }}>
            {monthNames[month]} {year}
          </Box>
          <Box sx={{ display: "flex", gap: 0.5 }}>
            <Button
              size="small"
              onClick={() => onMonthChange(-1)}
              sx={{ minWidth: "32px", p: 0.5 }}
            >
              <ChevronUp size={18} />
            </Button>
            <Button
              size="small"
              onClick={() => onMonthChange(1)}
              sx={{ minWidth: "32px", p: 0.5 }}
            >
              <ChevronDown size={18} />
            </Button>
          </Box>
        </Box>

        <Box
          sx={{
            display: "grid",
            gridTemplateColumns: "repeat(7, 1fr)",
            gap: 0.5,
            mb: 1,
          }}
        >
          {dayNames.map((day) => (
            <Box
              key={day}
              sx={{
                textAlign: "center",
                fontSize: "12px",
                fontWeight: 500,
                color: "#6B7280",
                py: 0.5,
              }}
            >
              {day}
            </Box>
          ))}
        </Box>

        <Box
          sx={{
            display: "grid",
            gridTemplateColumns: "repeat(7, 1fr)",
            gap: 0.5,
          }}
        >
          {days.map((dayObj, idx) => {
            const isInRange =
              dayObj.isCurrentMonth &&
              isDateInRange(dayObj.day, dayObj.month, dayObj.year);

            return (
              <Box
                key={idx}
                onClick={() =>
                  dayObj.isCurrentMonth &&
                  handleDateClick(dayObj.day, dayObj.month, dayObj.year)
                }
                sx={{
                  textAlign: "center",
                  py: 1,
                  fontSize: "13px",
                  color: dayObj.isCurrentMonth ? "#1F2937" : "#D1D5DB",
                  cursor: dayObj.isCurrentMonth ? "pointer" : "default",
                  borderRadius: "4px",
                  backgroundColor: isInRange ? "#E5E7EB" : "transparent",
                  "&:hover": dayObj.isCurrentMonth
                    ? { backgroundColor: "#F3F4F6" }
                    : {},
                }}
              >
                {dayObj.day}
              </Box>
            );
          })}
        </Box>
      </Box>
    );
  };

  return (
    <Box>
      <StyledAutocompleteFilter
        sx={{ width }}
        value={dateFilterOption}
        onChange={(event, newValue) => handleDateChange(newValue)}
        options={dateOptions}
        getOptionLabel={(option) => option.label}
        renderInput={(params) => (
          <TextField
            {...params}
            placeholder="Dates"
            InputProps={{
              ...params.InputProps,
              startAdornment: (
                <>
                  <Icon
                    Icon={autocompleteicon}
                    stroke="currentColor"
                    fill="transparent"
                    className="mr-2 w-4 text-gray-500"
                  />
                  {params.InputProps.startAdornment}
                </>
              ),
            }}
          />
        )}
      />

      <Dialog
        maxWidth="md"
        open={openDateDialog}
        onClose={() => setOpenDateDialog(false)}
        PaperProps={{
          sx: {
            borderRadius: "12px",
            maxWidth: "900px",
          },
        }}
      >
        <DialogTitle className="dialog-title">
          {t("select date range")}
        </DialogTitle>
        <Divider />
        <DialogContent sx={{ p: 3 }}>
          <Box sx={{ display: "flex", gap: 3 }}>
            {/* Left sidebar with filter options */}
            <Box
              sx={{
                minWidth: "140px",
                display: "flex",
                flexDirection: "column",
                gap: 1,
              }}
            >
              {dateOptions
                .filter((option) => option.label !== "custom")
                .map((widget) => {
                  const isSelected = selectedFilter === widget.label;

                  return (
                    <Box
                      key={widget.label}
                      onClick={() => handleFilterSelect(widget.label)}
                      sx={{
                        px: 2,
                        py: 1.5,
                        borderRadius: "8px",
                        cursor: "pointer",
                        backgroundColor: isSelected
                          ? "#F3F4F6"
                          : "transparent",
                        color: isSelected ? "#111827" : "#6B7280",
                        fontSize: "13px",
                        fontWeight: isSelected ? 600 : 500,
                        textTransform: "capitalize",
                        transition: "all 0.2s",
                        "&:hover": {
                          backgroundColor: "#F9FAFB",
                        },
                      }}
                    >
                      {widget.label}
                    </Box>
                  );
                })}
            </Box>

            {/* Right side with dual calendars */}
            <Box sx={{ flex: 1, display: "flex", gap: 3, flexWrap: "wrap" }}>
              {renderCalendar(leftMonth, changeLeftMonth)}
              {renderCalendar(rightMonth, changeRightMonth)}
            </Box>
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpenDateDialog(false)} color="primary">
            {t("cancel")}
          </Button>
          <Button onClick={applyCustomDate} color="primary" variant="contained">
            {t("apply")}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default DateFilterDropdown;
